# Gas Assessment – Savage Summit

Context: reviewed `src/systems/summit.cairo`, `src/models/beast.cairo`, and supporting utils/vrf/interfaces to map hot paths and storage usage. The main gas hotspots are `attack`/`attack_unsafe`, diplomacy bookkeeping, poison handling, and reward distribution (multiple external ERC20 calls + event dispatcher calls).

## Potential Optimizations
- **Cache beast base data locally (High gas / High complexity)** – `_get_beast` calls `beast_nft_dispatcher.get_beast` for every attack and diplomacy scan. Persist `PackableBeast` (or a minimal snapshot: health, level, prefix/suffix, shiny/animated) in Summit storage the first time a beast appears and read locally afterward. Reduces cross-contract syscalls per strike and per diplomacy reward.
- **Persist “last killed” info to skip data contract lookups (High gas / Medium-High complexity)** – `_assert_beast_can_attack` queries `beast_data_dispatcher.get_collectable_count/get_collectable` every attack. Track last kill timestamp in `LiveBeastStats` when deaths are observed (already stored) and rely on it instead of re-querying the data contract; optionally refresh lazily when mismatch is detected.
- **Precompute combat specs per fight (Med-High gas / Low-Med complexity)** – Inside `_attack`, `get_combat_spec` (includes `sqrt`) runs every strike for both beasts. Compute attacker/defender `CombatSpec` (and `critical_hit_chance`) once per attacking beast before the inner battle loop; pass them into `_attack` or inline the damage calc to avoid repeated sqrt + Poseidon span allocations.
- **Store derived level alongside XP (Med gas / Medium complexity)** – `_get_level_from_xp` (`sqrt`) is invoked each attack. Keep a `level` field in `LiveBeastStats` (updated when XP changes) or cache level in local scope per fight to skip repeated roots.
- **Short-circuit poison when count is zero (Med gas / Low complexity)** – `_apply_poison_damage` always writes `poison_timestamp` and does two `get_block_timestamp` syscalls even when `poison_count` is 0. Early-return before syscalls/writes when count is zero; pass the caller’s timestamp to reuse the same syscall.
- **Pass shared timestamps/caller through the attack flow (Med gas / Low complexity)** – `get_block_timestamp` and `get_caller_address` are called multiple times in `_attack_summit`, `_use_revival_potions`, and `_apply_poison_damage`. Grab them once per transaction and thread through helpers to cut syscall overhead; remove the unused `_summit_playable` call in `attack` that currently just burns gas.
- **Maintain diplomacy aggregates (High gas / Medium-High complexity)** – `_get_diplomacy_data` and `_get_diplomacy_bonus` iterate over `diplomacy_beast` and fetch each beast to sum power on every save/reward. Track `diplomacy_power` and `count` per `specials_hash` incrementally when stats unlock or beasts are removed so rewards and bonuses become O(1).
- **Slim event strategy (High gas / High complexity)** – Every `_save_beast` and battle emits via `summit_events_dispatcher` (cross-contract call) with many fields. Options: emit native events instead of dispatcher calls; add a “light mode” to skip non-critical events; or pack counts into a struct with fewer felts. Particularly, battle events currently store multiple counters that may be derivable off-chain.
- **Cache dispatchers per call (Low-Med gas / Low complexity)** – In several functions (`claim_beast_reward`, `add_extra_life`, poison, reward distribution) dispatcher reads repeat per iteration. Hoist dispatcher reads to locals outside loops and reuse to avoid map reads and hint-felt copies.
- **Batch ERC20 interactions where possible (Med gas / Medium complexity)** – `claim_beast_reward` does four sequential transfers; `attack` burns potions individually. If token contracts support batching or permit/allowance pre-approval, consolidate burns/transfers to reduce calldata and syscalls. At minimum, precompute `TOKEN_DECIMALS` multiples once and reuse.
- **Early exits in diplomacy/reward loops (Low-Med gas / Low complexity)** – In `_finalize_summit_history`, skip reward math when `blocks_on_summit == 0` or `diplomacy_count == 0` before computing `block_reward`/looping. Similar short-circuit in `_get_diplomacy_bonus` when `diplomacy_count <= 1` (currently only guards return; can also avoid Poseidon hash recompute by passing cached hash).
- **Tighten packing math paths (Low gas / Medium complexity)** – `LiveBeastStats` pack/unpack uses multiple `%`/`/` operations per read/write. If reads dominate writes, consider moving to `store_in_one_word` derivation or splitting hot fields (health/extra_lives/bonus_xp/timestamps) into a second, smaller struct to reduce arithmetic on every access; verify storage tradeoff vs compute cost.

## Hotspots to prioritize
- Attack loop (combat spec recomputation, syscall reuse, poison short-circuit).
- Diplomacy aggregation (currently scans + cross-contract reads on saves and rewards).
- Event emission path (dispatcher overhead and payload size).
